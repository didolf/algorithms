/**
 * Функция для нахождения последней цифры N-го числа фибоначи(рекурсивная).
 * @param num - номер числа фибоначи.
 * @return Цифра, которая является последней в N-ом числе фибоначи.
 */
export function lastNumOfFib(num) {
    if (typeof num !== "number")
        return 0;
    let fibCache = {};
    function fibLastNumHelper(num)
    {
        if (num === 0)
            return 0;
        if (num <= 2)
            return 1;
        let numMinTwo = (num - 2) in fibCache ? fibCache[num - 2] : fibCache[num - 2] = fibLastNumHelper(num - 2);
        let numMinOne = (num - 1) in fibCache ? fibCache[num - 1] : fibCache[num - 1] = fibLastNumHelper(num - 1);

        return ((numMinTwo + numMinOne) % 10);
    }
    return fibLastNumHelper(num > 0 ? num : -num);
}
/**
 * Функция для нахождения последней цифры N-го числа фибоначи(цикличная).
 * @param num - номер числа фибоначи.
 * @return Цифра, которая является последней в N-ом числе фибоначи.
 */
export function lastNumOfFibCycle(num)
{
    num = num > 0 ? num : -num;
    let i = 2;
    const fibCache = new Map();
    fibCache.set(0, 0);
    fibCache.set(1,1);
    if (num < 1)
        return fibCache.get(num);
    while (i <= num)
    {
        fibCache.set(i, (fibCache.get(i - 1) + fibCache.get(i - 2)) % 10);
        i++;
    }
    return (fibCache.get(num));
}
/**
 * Функция для вычисления N-го числа фибоначи. Использует кэширование на основе замыканий.
 * @param num - номер числа фибоначи.
 * @return Возвращает значение N-го числа фибоначи.
 */
export function fib(num)
{
    if (typeof num !== "number")
        return 0;
    let fibCache = new Map();
    function fibHelper(num)
    {
        if (num === 0)
            return 0;
        if (num <= 2)
            return 1;
        let numMinTwo = fibCache.has(num - 2) ? fibCache.get(num - 2) : fibCache.set(num - 2, fibHelper(num - 2)).get(num - 2);
        let numMinOne = fibCache.has(num - 1) ? fibCache.get(num - 1) : fibCache.set(num - 1, fibHelper(num - 1)).get(num - 1);
        return (numMinTwo + numMinOne);
    }
    return Math.sign(num) * fibHelper(num > 0 ? num : -num);
}
/**
 * Функция для вычисления N-го числа фибоначи(цикличная).
 * @param num - номер числа фибоначи.
 * @return Возвращает значение N-го числа фибоначи.
 */
function fibCycle(num)
{
    let sign;
    sign = num > 0 ? 1 : -1;
    num = sign * num;
    let i = 2;
    const fibCache = new Map();
    fibCache.set(0, 0);
    fibCache.set(1,1);
    if (num < 1)
        return (fibCache.get(num));
    while (i <= num)
    {
        fibCache.set(i, fibCache.get(i - 1) + fibCache.get(i - 2));
        i++;
    }
    return (sign * fibCache.get(num));
}

export function findPeriod(arr, hypothesis = 1n)
{
    let i = 0n;
    hypothesis = BigInt(hypothesis);
    while (i < BigInt(arr.length))
    {
        if (arr[i] !== arr[i % hypothesis])
        {
            hypothesis++;
            i = 0n;
        }
        else
            i++;
        if (hypothesis * 2n > arr.length)
            return (-1n);
    }
    return (hypothesis);
}

/**
 * Функция находит остаток от деления N-го числа фибоначи на mod.
 * Используется эвристика пеирода Пизано.
 * @param num - порядковый номер числа фибоначи.
 * @param mod - число, на которое делим число фибоначи.
 * @return Возвращает остаток от деления N-го числа фибоначи на mod.
 */
export function findFibMod(num, mod)
{
    num = num > 0 ? BigInt(num) : -1n * BigInt(num);
    mod = BigInt(mod);
    let i = 2n;
    let hypothesis = 1n;
    let period = -1n;
    const fibCache = [];
    fibCache[0] = 0n % mod;
    fibCache[1] = 1n % mod;
    if (num <= 1)
        return fibCache[num];
    while (i <= num && period == -1n)
    {
        fibCache[i] = (fibCache[i - 1n] + fibCache[i - 2n]) % mod;
        if (fibCache.length > hypothesis * 3n)
            period = findPeriod(fibCache, hypothesis++);
        i++;
    }
    return (period == -1 ? fibCache[num] : fibCache[num % BigInt(period)]);
}

export default fibCycle;